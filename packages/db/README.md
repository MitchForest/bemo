# @repo/db

Kysely bindings and migration scripts for the Bemo platform. The schema is intentionally compact so local development can boot without a database, while production runs against Supabase/Postgres with the same tables.

## What’s inside

```
src/
├─ index.ts          # getDb(), setAppUser(), withAppUser()
├─ migrate.ts        # Bun entry point for running migrations
├─ seed.ts           # Seeds curriculum + motivation content into Postgres
└─ database-types.ts # Generated by `bun run db:codegen`
```

`migrations/001_initial_schema.ts` creates the core schema (users, students, skills, task templates, motivation tables, etc.). `migrations/002_motivation_persistence.ts` layers on the motivation persistence tables (`student_league_memberships`, `student_quests`) and the indexed ledger timestamp required by the engine.

## Quick start

```bash
bun run db:migrate   # apply schema
bun run db:seed      # load curriculum/motivation seed content
bun run db:codegen   # regenerate Kysely types
```

Set `DATABASE_URL` before running these commands. If you skip the database entirely the engine/device fall back to in-memory seeds and you can still work locally, but remember that the second migration expects to run after the first.

## Helper exports

```ts
import { getDb, setAppUser, withAppUser } from "@repo/db";

const db = getDb();
const students = await db.selectFrom("students").selectAll().execute();

await withAppUser("student-uuid", async (trx) => {
  return trx
    .selectFrom("student_skill_states")
    .where("student_id", "=", "student-uuid")
    .selectAll()
    .execute();
});
```

- `getDb()` lazily constructs the Kysely client using `DATABASE_URL`.
- `setAppUser` / `withAppUser` set `app.user_id` for row level security policies once we turn them on.

## Schema outline

The initial migration creates:

- Auth & people: `users`, `sessions`, `accounts`, `students`, `parent_students`, `student_stats`.
- Curriculum: `organizations`, `subjects`, `courses`, `lessons`, `skills`, `skill_prerequisites`, `skill_encompassing`, `skill_task_templates`.
- Learning loop: `student_skill_states`, `evidence_events`, `skill_metrics`.
- Content & motivation: `assets`, `micro_games`, `practice_activities`, `check_charts`, `check_chart_entries`, `motivation_tracks`, `motivation_rewards`, `joy_breaks`.
- Learner motivation state: `student_league_memberships`, `student_quests`, `time_back_ledger` (with updated timestamps).

Everything lines up with the engine’s expectations (`packages/engine/src/data.ts`) and the content API (`apps/api/src/routes/content.ts`).

## Notes

- The migration uses enums for domains, grade bands, task types, results, and stage codes. If you extend these enums remember to regenerate types.
- RLS policies are not yet enabled—we’ll wire them up once auth-backed persistence ships. The helper functions already prepare the session variable (`app.user_id`).
- Seed data mirrors the curriculum package. You can safely run `bun run db:seed` multiple times; it upserts on IDs.

That’s it—you get a clean baseline schema with no legacy tables, aligned to the current engine and API.
